package osl.handler;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import osl.nameservice.MalformedNameException;
import osl.nameservice.Name;
import osl.nameservice.NameNotFoundException;
import osl.nameservice.NameService;
import osl.nameservice.NoBindingException;
import osl.nameservice.NoSuchAddressException;
import osl.transport.PhysicalAddress;
import osl.transport.TransportClient;
import osl.transport.TransportException;
import osl.transport.TransportInstance;
import osl.transport.TransportMessage;
import osl.util.Debug;
import osl.util.DeepCopy;
import osl.util.MethodStructure;
import osl.util.QueueSearch;
import osl.util.WaitQueue;

/**
 * A request handler session is used by clients to interact through the request
 * handler abstraction. In particular, outgoing requests are routed through
 * request handlers. Each request handler has a unique <em>PhysicalAddress</em>
 * with which it is associated.
 * <p>
 * 
 * Request handler clients also access the nameservice through sessions. In
 * particular, clients may generate new names as well as bind or unbind names to
 * the physical address of a particular session.
 * <p>
 * 
 * Handler sessions are implemented using the transport layer, thus this class
 * must implement the <em>TransportClient</em> interface in order to function
 * properly.
 * <p>
 * 
 * @author Mark Astley
 * @version $Revision: 1.9 $ ($Date: 1999/12/29 03:15:55 $)
 * @see RequestLayer
 * @see RequestException
 */

public class RequestSession implements TransportClient, Runnable {

	/**
	 * Set to true if you want debugging output.
	 */
	public static final boolean DEBUG = false;

	/**
	 * The <em>TransportInstance</em> we should use to communicate with external
	 * objects.
	 */
	TransportInstance transInstance = null;

	/**
	 * A reference to the <em>NameService</em> object which is used to resolve
	 * names for this session.
	 */
	NameService localNS = null;

	/**
	 * The <em>PhysicalAddress</em> associated with this session. We don't
	 * compute this until the client actually asks for it.
	 */
	PhysicalAddress ourAddress = null;

	/**
	 * The <em>RequestClient</em> to which we should deliver incoming requests.
	 */
	RequestClient ourClient = null;

	/**
	 * The method table holding all the methods exported by our client. We use
	 * this table to lookup the method to invoke when receive a remote request.
	 */
	Hashtable<?, ?> methodTable = null;

	/**
	 * The integer ID to assign to outgoing messages. We increment this value
	 * once for each message we send. In theory there shouldn't be any reused
	 * ids (i.e. when the counter wraps around) unless there is a REALLY long
	 * RPC stuck somewhere.
	 */
	long messageID = 0;

	/**
	 * This hashtable holds all the currently outstanding <em>RequestIDs</em>
	 * for asynchronous requests generated by this session. We periodically cull
	 * this table when we receive a GC_REQUESTIDS message from other request
	 * session clients.
	 */
	Hashtable<RequestID, RequestID> outstandingRequests = new Hashtable<RequestID, RequestID>();

	/**
	 * This hashtable hashes original sender <em>PhysicalAddresses</em> to a
	 * vector of request IDs indicating the set of completed requests initiated
	 * by the original sender. We periodically empty this vector into an array
	 * which is sent to each original sender so that they may GC their
	 * outstanding request tables.
	 */
	Hashtable<PhysicalAddress, Vector<Long>> completeRequests = new Hashtable<PhysicalAddress, Vector<Long>>();

	/**
	 * The timeout value in milliseconds which indicates how often we should
	 * send GC_REQUESTIDS messages to other sessions we have received requests
	 * from.
	 */
	int sendGCTimeout = 10000;

	/**
	 * The queue used to hold replies for requests with RPC semantics. Replies
	 * are held here until the waiting threads discover and remove them.
	 */
	WaitQueue<RequestMsg> rpcReplies = new WaitQueue<RequestMsg>();

	/**
	 * This hashtable hashes <em>Name</em>s to a <em>WaitQueue</em> which
	 * contains a reference to all the threads currently handling a local
	 * request targetted for this name. We use this queue to figure out when we
	 * can complete a remove request. We can't process a remove until all
	 * threads currently processing a request for the removed name have
	 * completed. This is because currently running threads might depend on
	 * local namebinding information for their correct execution.
	 */
	Hashtable<Name, WaitQueue<Thread>> inProgress = new Hashtable<Name, WaitQueue<Thread>>();

	/**
	 * This hashtable hashes <em>Name</em>s to an <em>Object</em> which
	 * suspended threads use to determine whether or not to resume. We use this
	 * table to keep track of incoming requests for names which are in the
	 * process of being removed. We awake these threads once the name has
	 * actually been removed and the name service is capable of delivering
	 * consistent information.
	 */
	Hashtable<Name, Name> toForward = new Hashtable<Name, Name>();

	/**
	 * Default constructor override. We provide this constructor so that users
	 * can't accidentally invoke a public default constructor and obtain an
	 * invalid <em>RequestSession</em> instance.
	 */
	RequestSession() {
		this(null, null, null);
	}

	/**
	 * Default constructor. Should only be called by the RequestHandler so we
	 * make it a package-protected constructor.
	 * 
	 * @param <b>client</b> The <em>RequestClient</em> which should receive
	 *        incoming requests.
	 * @param <b>meths</b> A <em>Hashtable</em> which holds all the methods that
	 *        our client exports to remote clients.
	 */
	RequestSession(RequestClient client, Hashtable<?, ?> meths,
			NameService service) {
		ourClient = client;
		methodTable = meths;
		localNS = service;
	}

	/**
	 * This function builds a <em>TranportMessage</em> structure given a
	 * <em>RequestMsg</em> structure to send. Note that we don't specify the
	 * sending or receiving address since this information is automatically
	 * filled in for us by the transport layer when we call
	 * <em>transportSend</em>.
	 * 
	 * @param <b>msg</b> The <em>RequestMsg</em> to be sent.
	 * @exception osl.handler.RequestException
	 *                Thrown if there is an error serializing the message or
	 *                constructing the low-level transport message.
	 */
	TransportMessage constructMsg(RequestMsg msg) throws RequestException {

		try {

			// Construct and return a transport message
			return new TransportMessage(DeepCopy.serialize(msg));

		} catch (Exception e) {
			throw new RequestException("Internal error serializing message", e);
		}
	}

	/**
	 * This function deserializes the raw data portion of a message and returns
	 * the resulting object, which should always be a <em>RequestMsg</em>. If
	 * not a <em>RequestException</em> is thrown.
	 * 
	 * @param <b>msg</b> The received <em>TransportMessage</em> structure.
	 * @exception osl.handler.RequestException
	 *                Thrown if there is an error deserializing the message.
	 */
	RequestMsg deconstructMsg(TransportMessage msg) throws RequestException {
		RequestMsg findData = null;
		RequestMsg toReturn = null;
		TransportMessage sendRequest = null;
		boolean found = false;
		Object[] resultMsg = null;
		RPCMatchingReply query = null;
		RequestMsg reply = null;

		// We keep looping until we either successfully deconstruct the
		// message, or we get an exception we can't recover from.
		try {
			do {
				try {
					// Deserialize the rawData portion of the message
					toReturn = (RequestMsg) DeepCopy.deserialize(msg.contents);
				} catch (ClassNotFoundException e) {
					// Ok, make an attempt to find the missing class by sending
					// a
					// REQUEST_CDATA message to the original sender.
					findData = new RequestMsg();
					findData.msgOrigSender = ourAddress;
					findData.type = RequestMsg.MTYPE_REQUEST_CDATA;
					findData.id = messageID++;
					findData.className = e.getMessage();

					sendRequest = constructMsg(findData);

					// Send the message, then block waiting for the reply
					try {
						transInstance.transportSend(msg.sender, sendRequest);
					} catch (Exception f) {
						throw new RequestException(
								"Error attempting to send outgoing message:", f);
					}

					query = new RPCMatchingReply(findData.id);

					while (!found)
						// We have to grab the lock and perform the search first
						// to avoid a race condition where the message arrives
						// before we actually start to wait for it.
						synchronized (rpcReplies) {
							resultMsg = rpcReplies.search(query);
							if (resultMsg.length == 0)
								try {
									// If we get here then we didn't find a
									// reply so wait
									// until we get one. We are awoken each time
									// a new entry
									// is placed into the reply queue.
									rpcReplies.wait();
								} catch (InterruptedException f) {
									// This is fatal if it happens
									System.err.println(f.toString());
									System.exit(1);
								}
							else
								found = true;
						}

					// Once we get the message, figure out what to do depending
					// on whether it is a REPLY_CDATA or an EXCEPTION.
					rpcReplies.remove((RequestMsg) resultMsg[0]);

					reply = (RequestMsg) resultMsg[0];
					switch (reply.type) {
					case RequestMsg.MTYPE_REPLY_CDATA:
						// Got the class data we wanted. Install the new local
						// class and try to deserialize again.
						if (RequestHandler.netLoader)
							NetLoader.addLocalClass(findData.className,
									reply.classData);
						break;
					case RequestMsg.MTYPE_RPC_EXCEPTION:
						// The sender barfed instead of sending us class data.
						// Just pass the exception to the outer code block.
						throw (Exception) reply.returnVal;
					default:
						System.err
								.println("Error: expected REPLY_CDATA or RPC_EXCEPTION: "
										+ reply);
						System.exit(1);
					}
				}
			} while (toReturn == null);
		} catch (Exception e) {
			// Anything which escapes the loop is something we can't recover
			// from so throw the exception.
			throw new RequestException("Error deserializing message", e);
		}

		return toReturn;
	}

	/**
	 * Submit an RPC request to a remote handler session client. The calling
	 * thread is blocked until a result or exception is received.
	 * 
	 * @param <b>target</b> The <em>PhysicalAddress</em> of the target of this
	 *        request.
	 * @param <b>msg</b> The <em>RequestMsg</em> structure to be sent.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if no matching method could be found in the remote
	 *                client. This indicates that the remote method was never
	 *                actually invoked.
	 * @exception osl.handler.RequestException
	 *                Thrown if an exception is caught while invoking the remote
	 *                method. This indicates that the remote method was invoked
	 *                (or attempted) but there was a client error.
	 */
	Object rpcRequest(PhysicalAddress target, RequestMsg msg)
			throws NoSuchMethodException, RequestException {
		// Construct and send out the original request
		TransportMessage tMsg = constructMsg(msg);
		RPCMatchingReply query = new RPCMatchingReply(msg.id);
		boolean found = false;
		Object[] resultMsg = null;
		RequestMsg reply = null;

		try {
			transInstance.transportSend(target, tMsg);
		} catch (Exception e) {
			throw new RequestException(
					"Error attempting to send outgoing message:", e);
		}

		// Sleep on the rpcReplies queue until we find a reply or
		// exception to our original request.
		// message
		while (!found)
			// We have to group the lock and perform the search first to
			// avoid a race condition where the message arrives before we
			// actually start to wait for it. Grabbing the lock here
			// prevents that from happening.
			synchronized (rpcReplies) {
				resultMsg = rpcReplies.search(query);
				if (resultMsg.length == 0)
					try {
						// if (DEBUG)
						// Log.println("<RequestSession.rpcRequest>: No reply found for ID "
						// + msg.id + ", sleeping");

						// If we get here then we didn't find a reply so wait
						// until we get one. We are awoken each time a new entry
						// is placed into the reply queue.
						rpcReplies.wait();

						// if (DEBUG)
						// Log.println("<RequestSession.rpcRequest>: Awake, looking for reply with ID "
						// + msg.id);
					} catch (InterruptedException e) {
						Debug.exit(e.toString());
					}
				else
					found = true;
			}

		// if (DEBUG)
		// Log.println("<RequestSession.rpcRequest>: Found reply for request with ID "
		// + msg.id);

		// Once we get the message, figure out what to do depending on
		// whether or not it is an exception or a reply.
		if (DEBUG)
			if (resultMsg.length != 1)
				Debug.exit("ERROR: Received " + resultMsg.length
						+ " replies to an RPC request!");
		rpcReplies.remove((RequestMsg) resultMsg[0]);

		reply = (RequestMsg) resultMsg[0];
		switch (reply.type) {
		case RequestMsg.MTYPE_RPC_REPLY:
			return reply.returnVal;
		case RequestMsg.MTYPE_RPC_EXCEPTION:
			if (reply.returnVal instanceof NoSuchMethodException)
				throw ((NoSuchMethodException) reply.returnVal);
			else
				throw ((RequestException) reply.returnVal);
		default:
			// Log.println("Error: expected RPC_REPLY or RPC_EXCEPTION: " +
			// reply);
		}

		// Need this line to make javac happy
		return null;
	}

	/**
	 * Package up and send a reply to an RPC request.
	 * 
	 * @param <b>tMsg</b> The original <em>TransportMessage</em> for the
	 *        request.
	 * @param <b>rMsg</b> The original <em>RequestMsg</em> for the request.
	 * @param <b>rVal</b> An <em>Object</em> giving the value to return to the
	 *        caller.
	 */
	void sendRPCReply(TransportMessage tMsg, RequestMsg rMsg, Object rVal) {
		try {
			// Build the reply message
			RequestMsg replyMsg = new RequestMsg(rVal, messageID++,
					RequestMsg.MTYPE_RPC_REPLY, rMsg);

			// Now construct a transport layer message
			TransportMessage transMsg = constructMsg(replyMsg);

			// Finally, send out the message
			transInstance.transportSend(rMsg.msgOrigSender, transMsg);
		} catch (Exception e) {
			// Log.println("Error in sendRPCReply: " + e.toString());
		}
	}

	/**
	 * This method is called when we receive a REQUEST or RPC_REQUEST message.
	 * The method is invoked on the object stored in the <em>ourClient</em>
	 * field. If the target method cannot be found then a NoSuchMethodException
	 * is thrown. If the target method generates any other error it is packaged
	 * in a RequestException and thrown back to the caller. Otherwise, we return
	 * whatever the called method returned.
	 * 
	 * @param <b>nextMethod</b> A <em>String</em> naming the next method to
	 *        invoke.
	 * @param <b>methodArgs</b> An array of <em>Objects</em> holding the
	 *        arguments to pass to the invoked method.
	 * @return An <b>Object</b> holding the return value of the invoked method.
	 *         If the return type is primitive, the return value is
	 *         automatically wrapped in an instance of the appropriate class.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if no method can be found in <em>ourClient</em>
	 *                which matches <em>nextMethod</em> and <em>methodArgs</em>.
	 * @exception osl.handler.RequestException
	 *                Thrown if the called method throws an exception which
	 *                propagates up to the request handler layer.
	 */
	Object invokeMethod(String nextMethod, Object[] methodArgs)
			throws NoSuchMethodException, RequestException {
		MethodStructure[] potMeths = null;
		Method toInvoke = null;
		boolean found = false;

		// -*- INVARIANT -*-
		// methodArgs can NOT be NULL. If no args are required, then
		// methodArgs should be an array of length 0.

		try {
			// Grab the method we are supposed to invoke, barf if we can't
			// find any such method
			potMeths = (MethodStructure[]) methodTable.get(nextMethod);
			if (potMeths == null) {
				if (DEBUG)
					// Log.println("potMeths was null, about to hurl...");
					throw new NoSuchMethodException("No method matching "
							+ nextMethod + " in remote client");
			}

			if (DEBUG)
				if (methodArgs == null) {
					// Log.println("(invokeMethod) methodArgs null");
				} else {
					String printit = "(invokeMethod) methodArgs = ";
					for (int m = 0; m < methodArgs.length; m++)
						printit = printit + methodArgs[m] + " ";
					// Log.println(printit);
				}

			for (int i = 0; (i < potMeths.length) && (!found); i++) {
				if (methodArgs == null) {
					if (potMeths[i].argTypes.length == 0) {
						found = true;
						toInvoke = potMeths[i].meth;
						break;
					} else
						continue;
				} else if (potMeths[i].argTypes == null)
					continue;
				else if (methodArgs.length != potMeths[i].argTypes.length)
					continue;

				found = true;
				toInvoke = potMeths[i].meth;
				for (int j = 0; j < potMeths[i].argTypes.length; j++)
					if ((methodArgs[j] != null)
							&& (!potMeths[i].argTypes[j]
									.isInstance(methodArgs[j]))) {
						found = false;
						break;
					}
			}

			if (!found)
				throw new NoSuchMethodException("No method matching "
						+ nextMethod + " in remote client");

			// Now invoke the method, return the result, or null if the
			// result type is primitive.
			// if (DEBUG)
			// Log.println("About to invoke " + toInvoke + " on client");
			return toInvoke.invoke(ourClient, methodArgs);

		} catch (NoSuchMethodException e) {
			// if (DEBUG)
			// Log.println("No method matching " + nextMethod +
			// ", throwing exception");
			throw e;
		} catch (InvocationTargetException e) {
			throw new RequestException("Error from within client method:", (e)
					.getTargetException());
		} catch (Exception e) {
			throw new RequestException("Error in remote client:", e);
		}
	}

	/**
	 * Called when the transport layer has received a new message on a
	 * connection associated with this client. If a client holds several
	 * connections it is their responsibility to demultiplex incoming messages
	 * as appropriate. The <b>target</b> field may be used to determine which
	 * connection this message is associated with.
	 * 
	 * @param <b>target</b> The <em>TransportInstance</em> reference that this
	 *        message is targeted for. By assumption, the client is the owner of
	 *        this instance.
	 * @param <b>msg</b> The <em>TransportMessage</em> that was received for
	 *        this connection.
	 */
	public void transportReceive(TransportInstance target, TransportMessage msg) {
		// -*- INVARIANT -*-
		// The data received from the transport layer must contain an
		// instance of RequestMsg. Any error we encounter here will
		// result in an Exception message being sent back to the
		// originator of the message. We also log the error to our local
		// error system (to be implemented).
		RequestMsg nextMsg = null;
		RequestID eID = null;

		// Setup the new transport thread to be logged in the local System log
		/*
		 * try { Log.logThread("System", Thread.currentThread()); } catch
		 * (Exception e) { Log.println(FoundryStart.sysLog,
		 * "Error logging transport thread: " + e); }
		 */
		// PRAGMA [debug,osl.handler.RequestSession]
		// Log.println("<RequestSession.transportReceive> Processing transport message");
		try {

			nextMsg = deconstructMsg(msg);

			// Now figure out what to do with the message based on its type
			switch (nextMsg.type) {

			case RequestMsg.MTYPE_RPC_REPLY:
			case RequestMsg.MTYPE_RPC_EXCEPTION:
			case RequestMsg.MTYPE_REPLY_CDATA:
				// If this is an RPC reply or RPC exception then one of our
				// threads is waiting on it so put it in the rpcReplies queue.
				// The same holds true if this is a REPLY_CDATA message: one
				// of our threads is waiting on a previous REQUEST_CDATA
				// message.

				// PRAGMA [debug,osl.handler.RequestSession] if (nextMsg.type ==
				// RequestMsg.MTYPE_RPC_REPLY)
				// PRAGMA [debug,osl.handler.RequestSession]
				// Log.println("<RequestSession.transportReceive> Received RPC_REPLY with ID "
				// + nextMsg.id + " (srcID " + nextMsg.srcID + ")");
				// PRAGMA [debug,osl.handler.RequestSession] else if
				// (nextMsg.type == RequestMsg.MTYPE_RPC_EXCEPTION)
				// PRAGMA [debug,osl.handler.RequestSession]
				// Log.println("<RequestSession.transportReceive> Received RPC_EXCEPTION with ID "
				// + nextMsg.id + " (srcID " + nextMsg.srcID + ")");
				// PRAGMA [debug,osl.handler.RequestSession] else if
				// (nextMsg.type == RequestMsg.MTYPE_REPLY_CDATA)
				// PRAGMA [debug,osl.handler.RequestSession]
				// Log.println("<RequestSession.transportReceive> Received REPLY_CDATA with ID "
				// + nextMsg.id + " (srcID " + nextMsg.srcID + ")");

				rpcReplies.enqueue(nextMsg);
				break;

			case RequestMsg.MTYPE_RPC_REQUEST:
				// Service the request as an RPC
				// PRAGMA [debug,osl.handler.RequestSession]
				// Log.println("<RequestSession.transportReceive> Received RPC_REQUEST");
				serviceRequest(msg, nextMsg, true);
				break;

			case RequestMsg.MTYPE_REQUEST:
				// Service the request as a regular request
				// PRAGMA [debug,osl.handler.RequestSession]
				// Log.println("<RequestSession.transportReceive> Received REQUEST");
				serviceRequest(msg, nextMsg, false);

				// Once the request has completed, store its ID in the
				// completeRequests table so that an appropriate GC message is
				// sent to the original caller.
				try {
					completeRequests.get(nextMsg.msgOrigSender).addElement(
							new Long(nextMsg.id));
				} catch (NullPointerException e) {
					// This is caught when there isn't an entry for this sender
					// in the completeRequests table yet.
					Vector<Long> newEntry = new Vector<Long>();
					newEntry.addElement(new Long(nextMsg.id));
					completeRequests.put(nextMsg.msgOrigSender, newEntry);
				}
				break;

			case RequestMsg.MTYPE_EXCEPTION:
				// This is an exception we received from an earlier request.
				// Remove the RequestID for the original request and return it
				// along with the exception to our client.
				// PRAGMA [debug,osl.handler.RequestSession]
				// Log.println("<RequestSession.transportReceive> Received EXCEPTION");

				eID = outstandingRequests.get(new RequestID(false,
						nextMsg.srcID));
				outstandingRequests.remove(eID);
				eID.valid = false;
				ourClient.handlerException(this, (Exception) nextMsg.returnVal,
						eID);
				break;

			case RequestMsg.MTYPE_GC_REQUESTIDS:
				// Garbage collect old request IDs. We garbage collect by
				// first setting each ID to be invalid and then removing it
				// from the outstandingRequests table.
				// if (DEBUG)
				// Log.println("Received GC_REQUESTIDS");

				for (int i = 0; i < nextMsg.gcReqs.length; i++) {
					eID = outstandingRequests.get(new RequestID(false,
							nextMsg.gcReqs[i]));
					if (eID != null) {
						// if (DEBUG)
						// Log.println("GCing: " + eID + " with ID: " +
						// nextMsg.gcReqs[i]);
						outstandingRequests.remove(eID);
						eID.valid = false;
					}
				}
				break;

			case RequestMsg.MTYPE_REQUEST_CDATA:
				// Ok, someone wants class data for a message we previously
				// sent (or forwarded). Track down the class data and send
				// it, the exception that results from the attempt.
				// if (DEBUG)
				// Log.println("Received REQUEST_CDATA");

				try {
					if (!RequestHandler.netLoader)
						throw new RuntimeException(
								"the NetLoader service is not in use");

					// Get the local class data
					byte[] cData = NetLoader.getLocalClass(nextMsg.className);

					// Then build and and send a reply message
					RequestMsg replyMsg = new RequestMsg();
					replyMsg.msgOrigSender = ourAddress;
					replyMsg.type = RequestMsg.MTYPE_REPLY_CDATA;
					replyMsg.id = messageID++;
					replyMsg.srcID = nextMsg.id;
					replyMsg.classData = cData;

					TransportMessage sendRequest = constructMsg(replyMsg);
					transInstance.transportSend(nextMsg.msgOrigSender,
							sendRequest);

				} catch (Exception e) {
					// Any exception we get will cause us to send back an
					// RPC_EXCEPTION message. We just log any exception that
					// results when we try to send back the exception message.
					try {
						RequestMsg exMsg = new RequestMsg(e, messageID++,
								RequestMsg.MTYPE_RPC_EXCEPTION, nextMsg);
						TransportMessage tMsg = constructMsg(exMsg);
						transInstance
								.transportSend(nextMsg.msgOrigSender, tMsg);
					} catch (Exception E) {
						// Log.println("Error sending exception message: " + E);
					}
				}
				break;

			default:
				// Don't understand the message type. Eventually we will want
				// to log this error to our error system. But until that's
				// implemented, just print out a debugging message.
				// Log.println("Warning: received unknown MTYPE type " +
				// nextMsg.type);
				break;
			} // switch...
		} catch (Exception e) {
			e.printStackTrace(Debug.out);
			Debug.exit(e.toString());
		}
	}

	/**
	 * Called if the transport layer encounters an exception while attempting to
	 * send a previously queued message. If a client holds several connections
	 * it is their responsibility to demultiplex incoming messages as
	 * appropriate. The <b>target</b> field may be used to determine which
	 * connection this message is associated with.
	 * 
	 * @param <b>target</b> The <em>TransportInstance</em> reference that the
	 *        original message was sent from. By assumption, the client is the
	 *        owner of this instance.
	 * @param <b>msg</b> The original <em>TransportMessage</em> that was queued
	 *        to be sent to the remote host.
	 * @param <b>error</b> The <em>TransportException</em> which encapsulates
	 *        the error encountered during transmission.
	 */
	public void transportException(TransportInstance target,
			TransportMessage msg, TransportException error) {
		// stub for now
	}

	/**
	 * The run method for this session. Currently, the thread which executes in
	 * the run method is responsible for periodically sending GC_REQUESTIDS
	 * messages to other sessions. This thread sleeps on a timer and, when
	 * awakened, dumps the contents of the completeRequests hashtable onto the
	 * network.
	 */
	public void run() {
		try {
			while (true) {
				Thread.sleep(sendGCTimeout);

				for (Enumeration<PhysicalAddress> e = completeRequests.keys(); e
						.hasMoreElements();) {
					PhysicalAddress sender = e.nextElement();

					// A nasty side effect of concurrency and Hashtable
					// enumeration. The values in your enumeration can get
					// trashed if someone does a concurrent "remove" while you
					// are scanning the table. Hence the non-null check here.
					if (sender != null) {
						Vector<Long> toGC = completeRequests.get(sender);

						if ((toGC != null) && (toGC.size() != 0)) {
							// We synchronize here to stop other threads from
							// adding
							// to the "toGC" list while we are busy dumping it.
							// Note
							// that if we didn't do this we might lose some IDs
							// when
							// we do the "toGC.removeAllElements" call below.
							synchronized (toGC) {
								Long[] copy = new Long[toGC.size()];
								long[] send = new long[toGC.size()];

								toGC.copyInto(copy);
								for (int i = 0; i < copy.length; i++)
									send[i] = copy[i].longValue();

								RequestMsg toSend = new RequestMsg(ourAddress,
										null, RequestMsg.MTYPE_GC_REQUESTIDS,
										messageID++, -1, null, null, null,
										send, null, null);
								TransportMessage tMsg = constructMsg(toSend);
								transInstance.transportSend(sender, tMsg);

								// Last thing, clean out the vector we just sent
								toGC.removeAllElements();
							}
						}
					}
				}
			}
		} catch (Exception err) {
			Debug.exit("Fatal Error while running GC thread: " + err);
		}
	}

	/**
	 * Handle an incoming REQUEST or RPC_REQUEST.
	 * 
	 * @param <b>msg</b> The original <em>TransportMessage</em> holding the
	 *        request.
	 * @param <b>rMsg</b> The original <em>RequestMsg</em> holding the request.
	 * @param <b>rpcP</b> <tt>TRUE</tt> if this is an RPC request,
	 *        <tt>FALSE</tt> otherwise.
	 */
	void serviceRequest(TransportMessage msg, RequestMsg rMsg, boolean rpcP) {
		Name target = null;
		PhysicalAddress rpc = null;
		Object rpcResult = null;
		PhysicalAddress forward = null;
		// Object rlock = null;
		WaitQueue<Thread> prog = null;

		try {

			target = rMsg.msgDestName;

			// If this is an RPC then save the address where we should send
			// the reply message to.
			if (rpcP)
				rpc = rMsg.msgOrigSender;

			// All critical sections for managing requests must first lock
			// the inProgress table.
			synchronized (inProgress) {

				// If we don't have an inProgress entry for this name then
				// either the message wasn't intended for us or we are in the
				// process of removing this name. If we don't have a
				// toForward entry for this name then this message should be
				// immediately forwarded.
				if (inProgress.get(target) == null) {
					if (toForward.get(target) == null)
						try {
							// This message isn't for us so figure out where to
							// ship
							// the message and send it off. Nothing needs to be
							// changed in the RequestMessage structure itself as
							// the
							// msgOrigSender field contains the correct reply
							// address.
							localNS.nsClear(target);
							forward = localNS.nsLookup(target);
							transInstance.transportSend(forward, msg);

							// Immediately return after forwarding the message
							return;
						} catch (Exception e) {
							// If the name is mangled or we can't seem to look
							// it up
							// then send an exception back to the original
							// caller. Note
							// that we may need to catch a transport exception
							// while
							// attempting to send the reply!!!
							try {
								RequestMsg exMsg = new RequestMsg(
										e,
										messageID++,
										(rpcP ? RequestMsg.MTYPE_EXCEPTION
												: RequestMsg.MTYPE_RPC_EXCEPTION),
										rMsg);
								TransportMessage tMsg = constructMsg(exMsg);
								transInstance.transportSend(rMsg.msgOrigSender,
										tMsg);

								// Immediately return after sending the
								// exception message
								return;
							} catch (Exception E) {
								// Log.println("Error sending exception message: "
								// + E);
							}
						}
					else {
						// This name is in the process of being removed. Block
						// ourselves until the toForward entry has been removed.
						while (toForward.get(target) != null)
							inProgress.wait();

						// If we get here then it's time to forward the message.
						try {
							// Figure out where to ship the message and send it
							// off.
							// Nothing needs to be changed in the RequestMessage
							// structure itself as the msgOrigSender field
							// contains the
							// correct reply address.
							localNS.nsClear(target);
							forward = localNS.nsLookup(target);
							transInstance.transportSend(forward, msg);

							// Immediately return after sending the message
							return;
						} catch (Exception e) {
							// If the name is mangled or we can't seem to look
							// it up
							// then send an exception back to the original
							// caller. Note
							// that we may need to catch a transport exception
							// while
							// attempting to send the reply!!!
							try {
								RequestMsg exMsg = new RequestMsg(
										e,
										messageID++,
										(rpcP ? RequestMsg.MTYPE_EXCEPTION
												: RequestMsg.MTYPE_RPC_EXCEPTION),
										rMsg);
								TransportMessage tMsg = constructMsg(exMsg);
								transInstance.transportSend(rMsg.msgOrigSender,
										tMsg);

								// Immediately return after sending the
								// exception
								return;
							} catch (Exception E) {
								// Log.println("Error sending exception message: "
								// + E);
							}
						}
					}
				}

				// If we get here then it's safe to make the call on our
				// client. Before we release the inProgress lock, add
				// ourselves to the inProgress WaitQueue. We enqueue our
				// thread so that each entry is unique in the queue.
				// We have to save a reference to the queue here because the
				// inProgress binding will be removed during a handlerRemove
				// call.
				prog = inProgress.get(target);
				prog.enqueue(Thread.currentThread());

				// Now release the inProgress lock and make the actual
				// invocation.
			}

			// Make the call on the target object. If we get an exception
			// then package it up and send it back to the caller (either
			// as MTYPE_RPC_EXCEPTION or MTYPE_EXCEPTION).
			try {
				// PRAGMA [debug,osl.handler.RequestSession]
				// Log.println("<RequestSession.serviceRequest> Making call on local client");
				rpcResult = invokeMethod(rMsg.targetMethod, rMsg.args);

				// See if we need to send a reply
				if (rpcP) {
					// PRAGMA [debug,osl.handler.RequestSession]
					// Log.println("<RequestSession.serviceRequest> Sending RPC reply message");
					sendRPCReply(msg, rMsg, rpcResult);
				}

			} catch (Exception e) {
				// If this is a RequestException or a NoSuchMethodException
				// then we package it up appropriately and send it back to
				// the caller. Otherwise this is a fatal error and we print
				// it out.
				if ((e instanceof NoSuchMethodException)
						|| (e instanceof RequestException))
					try {
						// if (DEBUG)
						// Log.println("Caught exception, sending to caller: " +
						// msg.sender);
						RequestMsg exMsg = new RequestMsg(e, messageID++,
								((rpc == null) ? RequestMsg.MTYPE_EXCEPTION
										: RequestMsg.MTYPE_RPC_EXCEPTION), rMsg);
						TransportMessage tMsg = constructMsg(exMsg);
						transInstance.transportSend(msg.sender, tMsg);
					} catch (Exception e1) {
						// Log.println("Error sending exception message: " +
						// e1);
					}
				else {
					// Log.println("Internal error while handling request: " +
					// e);
				}
			}
		} catch (Exception e) {
			Debug.exit(e.toString());
		}

		// Last thing before we exit is to remove ourselves from the
		// inProgress queue. This is so a thread blocked on a
		// handlerRemove can eventually make progress.
		prog.remove(Thread.currentThread());

	}

	// ////////////////////////////////////////////////////////////////////
	// ////// Methods Exported to Request Client //////////////////////////
	// ////////////////////////////////////////////////////////////////////
	/**
	 * This method returns the <em>PhysicalAddress</em> associated with this
	 * handler session.
	 */
	public PhysicalAddress handlerGetAddress() {
		return ourAddress;
	}

	/**
	 * This method is used to invoke an asynchronous request on a named target.
	 * Any exceptions which result from this request will be delivered
	 * asynchronously to the <em>RequestClient</em> associated with this
	 * session. This version of the method generalizes the variable arguments
	 * versions defined below.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>args</b> The arguments to be passed to the target method.
	 * @return The <em>RequestID</em> associated with this request. This value
	 *         may be used to later identify the request if it asynchronously
	 *         throws an exception. A <em>RequestID</em> may later become
	 *         invalid once the original request has been safely handled. The
	 *         <em>RequestID.isValid</em> method may be used to determine when
	 *         it is safe to garbage collect a request ID.
	 */
	public RequestID handlerRequest(Name target, String method, Object[] args)
			throws RequestException {
		// Build and send a request message. Throw nameservice errors if we get
		// em...
		long msgID = messageID++;
		RequestMsg rMsg = new RequestMsg(ourAddress, target,
				RequestMsg.MTYPE_REQUEST, method, args, msgID);
		RequestID rID = new RequestID(true, msgID);
		TransportMessage tMsg = constructMsg(rMsg);
		PhysicalAddress dest = null;

		// PRAGMA [debug,osl.handler.RequestSession]
		// Log.println("<RequestSession.handlerRequest> Starting request...");

		// Record the request as outstanding
		outstandingRequests.put(rID, rID);

		try {
			// PRAGMA [debug,osl.handler.RequestSession]
			// Log.println("<RequestSession.handlerRequest> Looking up name: " +
			// target);
			dest = localNS.nsLookup(target);
		} catch (Exception e) {
			throw new RequestException(
					"Error looking up local name: " + target, e);
		}

		try {
			// PRAGMA [debug,osl.handler.RequestSession]
			// Log.println("<RequestSession.handlerRequest> Sending transport message from address: "
			// + ourAddress);
			transInstance.transportSend(dest, tMsg);
		} catch (TransportException e) {
			throw new RequestException(
					"Error passing message through transport layer", e);
		}

		// PRAGMA [debug,osl.handler.RequestSession]
		// Log.println("<RequestSession.handlerRequest> Request complete...");

		return rID;
	}

	/**
	 * This method is used to invoke a synchronous request on a named target.
	 * Semantically, this invocation is equivalent to a Remote Procedure Call
	 * (RPC). That is, the caller blocks until the target returns a reply. Any
	 * exceptions which result from this call are immediately delivered to the
	 * caller rather than being delivered to the client's
	 * <em>handlerException</em> method. This version of the method generalizes
	 * the variable arguments versions defined below.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>args</b> The arguments to be passed to the target method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object[] args)
			throws RequestException, NoSuchMethodException {
		// Build and send a request message. Throw nameservice errors if we get
		// em...
		RequestMsg rMsg = new RequestMsg(ourAddress, target,
				RequestMsg.MTYPE_RPC_REQUEST, method, args, messageID++);
		PhysicalAddress dest = null;

		try {
			dest = localNS.nsLookup(target);
		} catch (Exception e) {
			throw new RequestException(
					"Error looking up local name: " + target, e);
		}

		return rpcRequest(dest, rMsg);
	}

	/**
	 * Request a new globally unique name.
	 */
	public Name handlerGenerateName() {
		return localNS.nsGenerateName();
	}

	/**
	 * Indicate that we wish to receive messages targeted for the given name.
	 * 
	 * @param <b>N</b> The <em>Name</em> we wish to receive requests for.
	 * @exception osl.nameservice.MalformedNameException
	 *                Thrown if the name argument does not represent a legal
	 *                name.
	 */
	public void handlerRegister(Name N) throws MalformedNameException {
		// Each time a new name is registered we need to add an inProgress
		// entry to hold threads which are currently handling requests for
		// the registered name.
		// if (DEBUG)
		// Log.println("<RequestSession.handlerRegister> Attempting to grab inProgress lock");
		synchronized (inProgress) {
			try {
				// if (DEBUG)
				// Log.println("<RequestSession.handlerRegister> Calling ns to register new address");
				localNS.nsRegister(N, ourAddress);
			} catch (Exception e) {
				// Log.println("<RequestSession.handlerRegister> Fatal error: Abusing name service!");
				// Log.logExceptionTrace(e);
				System.exit(1);
			}

			if (inProgress.get(N) == null)
				inProgress.put(N, new WaitQueue<Thread>());
		}

		// if (DEBUG)
		// Log.println("<RequestSession.handlerRegister> Lock released, exiting");
	}

	/**
	 * Indicate that this handler session should no longer accept requests for
	 * the given name. The semantics of this method are somewhat complicated. To
	 * avoid inconsistencies, this call does not return until all current
	 * invocations of requests targeted for <em>N</em> have safely exited the
	 * session client. The number of such calls is always finite as incoming
	 * calls are suspended and forwarded once the name has been removed and the
	 * nameservice has a chance to update it's information. Note that if the
	 * thread making this call also happens to be a request targeted to
	 * <em>N</em> then a deadlock will result.
	 * 
	 * @param <b>N</b> The <em>Name</em> to unbind.
	 * @exception osl.nameservice.MalformedNameException
	 *                Thrown if the name argument does not represent a legal
	 *                name.
	 * @exception osl.nameservice.NameNotFoundException
	 *                Thrown if the name argument can not be found in the local
	 *                authoritative name table.
	 */
	public void handlerRemove(Name N) throws MalformedNameException,
			NameNotFoundException {
		WaitQueue<Thread> current = null;

		// Grab the inProgress lock before doing anything.
		// if (DEBUG)
		// Log.println("<handlerRemove> About to grab inProgress lock...");
		synchronized (inProgress) {
			// First check to see if we really have the binding and grab the
			// current queue of active threads.
			current = inProgress.get(N);
			if (current == null)
				// We don't have this name binding so barf out an exception
				throw new NameNotFoundException("No binding for name: " + N);

			// Got the queue. Now create a toForward entry to indicate that
			// this name is in the process of being removed.
			toForward.put(N, N);

			// Finally, remove the entry from the inProgress table so that
			// new incoming requests are automatically blocked and
			// eventually forwarded.
			inProgress.remove(N);
		}

		// Now wait on the current queue until it is empty. When it
		// empties we can actually remove the name, etc. Have to
		// synchronize here to avoid the race condition where the queue
		// empties just before we start to wait on it.
		// if (DEBUG)
		// Log.println("<handlerRemove> About to synchronize with current session threads...");
		try {
			synchronized (current) {
				// if (DEBUG)
				// Log.println("<handlerRemove> Grabbed current session thread lock...");
				while (!current.empty()) {
					// if (DEBUG)
					// Log.println("<handlerRemove> Current has " +
					// current.numElements() + " entries, waiting");
					current.wait();
				}
			}
		} catch (InterruptedException e) {
			Debug
					.exit("Fatal Error: Waiting thread should never be interrupted!");
		}

		// if (DEBUG)
		// Log.println("<handlerRemove> Synchronization complete, calling nameservice to remove binding");

		// Ok, all in progress requests have terminated. Now implement
		// the remove with the nameservice.
		try {
			localNS.nsRemove(N, ourAddress);
		} catch (NoSuchAddressException e) {
			// Log.println("Fatal error: Abused name service!");
			// Log.logExceptionTrace(e);
			System.exit(1);
		}

		// Once this is done, remove the toForward entry and wake up any
		// threads suspended for incoming requests. Note that for
		// consistency we have to grab the inProgress lock first.
		// if (DEBUG)
		// Log.println("<handlerRemove> Remove binding complete, waking up waiting local threads");
		synchronized (inProgress) {
			toForward.remove(N);
			inProgress.notifyAll();
		}
	}

	/**
	 * Attempt to find the physical address associated with a particular name.
	 * 
	 * @param <b>namu</b> The <em>Name</em> instance to be resolved.
	 * @exception osl.nameservice.MalformedNameException
	 *                Thrown if the given name argument is an illegal name
	 *                representation. This may occur if a name from another
	 *                nameservice is used or if a client attempts to spoof an
	 *                illegal name.
	 * @exception osl.nameservice.NameNotFoundException
	 *                Thrown if the given name argument is a legal name but no
	 *                binding information can be found.
	 * @exception osl.nameservice.NoBindingException
	 *                Thrown if the given name argument is a legal name but
	 *                currently has no associated <em>PhysicalAddress</em>
	 *                binding.
	 */
	public PhysicalAddress handlerLookup(Name namu)
			throws MalformedNameException, NameNotFoundException,
			NoBindingException {
		try {
			return localNS.nsLookup(namu);
		} catch (Exception e) {
			throw new NoBindingException(
					"No bindings to a physical address exist in the name service");
		}
	}

	/**
	 * Returns true if <b>namu</b> is bound authoritatively to the
	 * <em>PhysicalAddress</em> associated with this handler session.
	 * 
	 * @param <b>namu</b> The <em>Name</em> to be looked up.
	 * @exception osl.nameservice.MalformedNameException
	 *                Thrown if the given name argument is an illegal name
	 *                representation. This may occur if a name from another
	 *                nameservice is used or if a client attempts to spoof an
	 *                illegal name.
	 */
	public boolean handlerLocal(Name namu) throws MalformedNameException {
		try {
			return localNS.nsLocal(namu, ourAddress);
		} catch (NoSuchAddressException e) {
			// Log.println("Fatal error: Abusing name service!");
			// Log.logExceptionTrace(e);
			System.exit(1);
		}

		return false;
	}

	/**
	 * Instructs the nameservice associated with this handler session to clear
	 * non-authoritative information about the given name. Typically, this means
	 * clearing any cache entries associated with the given name. Note that no
	 * action is taken if <b>namu</b> refers to an authoritative entry.
	 * 
	 * @param <b>namu</b> The <em>Name</em> for which non-authoritative
	 *        information should be cleared.
	 * @exception osl.nameservice.MalformedNameException
	 *                Thrown if the given name argument is an illegal name
	 *                representation. This may occur if a name from another
	 *                nameservice is used or if a client attempts to spoof an
	 *                illegal name.
	 */
	public void handlerClear(Name namu) throws MalformedNameException {
		localNS.nsClear(namu);
	}

	// ////////////////////////////////////////////////////////////////
	// ////////////////////////////////////////////////////////////////
	// /////// VarArgs versions of handlerRequest and handlerRPCRequest
	// ////////////////////////////////////////////////////////////////
	// ////////////////////////////////////////////////////////////////

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 */
	public RequestID handlerRequest(Name target, String method)
			throws RequestException {
		return handlerRequest(target, method, new Object[0]);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1)
			throws RequestException {
		Object[] theArgs = { arg1 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2) throws RequestException {
		Object[] theArgs = { arg1, arg2 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5)
			throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
			throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10)
			throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11)
			throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15)
			throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15, Object arg16)
			throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg17</b> The seventeenth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15,
			Object arg16, Object arg17) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg17</b> The seventeenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg18</b> The eighteenth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15,
			Object arg16, Object arg17, Object arg18) throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
				arg18 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg17</b> The seventeenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg18</b> The eighteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg19</b> The nineteenth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15,
			Object arg16, Object arg17, Object arg18, Object arg19)
			throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
				arg18, arg19 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg17</b> The seventeenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg18</b> The eighteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg19</b> The nineteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg20</b> The twentieth argument to be passed to the remote
	 *        method.
	 */
	public RequestID handlerRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15,
			Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
			throws RequestException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
				arg18, arg19, arg20 };
		return handlerRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method)
			throws RequestException, NoSuchMethodException {
		return handlerRPCRequest(target, method, new Object[0]);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2) throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3) throws RequestException,
			NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4) throws RequestException,
			NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7) throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8) throws RequestException,
			NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9) throws RequestException,
			NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12) throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13) throws RequestException,
			NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14) throws RequestException,
			NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15, Object arg16)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg17</b> The seventeenth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15,
			Object arg16, Object arg17) throws RequestException,
			NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg17</b> The seventeenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg18</b> The eighteenth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15,
			Object arg16, Object arg17, Object arg18) throws RequestException,
			NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
				arg18 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg17</b> The seventeenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg18</b> The eighteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg19</b> The nineteenth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15,
			Object arg16, Object arg17, Object arg18, Object arg19)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
				arg18, arg19 };
		return handlerRPCRequest(target, method, theArgs);
	}

	/**
	 * This version of <em>handlerRPCRequest</em> is a convenient alias for the
	 * version defined above. We provide this alias because Java does not have
	 * any "variable argument" extensions which allow functions to take a
	 * run-time determined argument list. Therefore, we provide 21 aliases for
	 * this function which take from 0 to 20 object arguments. Each alias
	 * creates an array to hold the arguments and called <em>handlerRequest</em>
	 * defined above.
	 * 
	 * @param <b>target</b> The <em>Name</em> of the handler client to send the
	 *        asynchronous request to.
	 * @param <b>method</b> The <em>String</em> name of the method to invoke on
	 *        the target.
	 * @param <b>arg1</b> The first argument to be passed to the remote method.
	 * @param <b>arg2</b> The secondargument to be passed to the remote method.
	 * @param <b>arg3</b> The third argument to be passed to the remote method.
	 * @param <b>arg4</b> The fourth argument to be passed to the remote method.
	 * @param <b>arg5</b> The fifth argument to be passed to the remote method.
	 * @param <b>arg6</b> The sixth argument to be passed to the remote method.
	 * @param <b>arg7</b> The seventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg8</b> The eighth argument to be passed to the remote method.
	 * @param <b>arg9</b> The ninth argument to be passed to the remote method.
	 * @param <b>arg10</b> The tenth argument to be passed to the remote method.
	 * @param <b>arg11</b> The eleventh argument to be passed to the remote
	 *        method.
	 * @param <b>arg12</b> The twelfth argument to be passed to the remote
	 *        method.
	 * @param <b>arg13</b> The thirteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg14</b> The fourteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg15</b> The fifteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg16</b> The sixteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg17</b> The seventeenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg18</b> The eighteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg19</b> The nineteenth argument to be passed to the remote
	 *        method.
	 * @param <b>arg20</b> The twentieth argument to be passed to the remote
	 *        method.
	 * @exception osl.handler.RequestException
	 *                Thrown if the invoked method on the target client throws
	 *                an exception. This exception is only a wrapper for the
	 *                real exception thrown by the remote handler client.
	 * @exception java.lang.NoSuchMethodException
	 *                Thrown if the given method and arguments do not match any
	 *                exported method of the target. Receiving this exception
	 *                indicates that the method was never actually invoked on
	 *                the target.
	 */
	public Object handlerRPCRequest(Name target, String method, Object arg1,
			Object arg2, Object arg3, Object arg4, Object arg5, Object arg6,
			Object arg7, Object arg8, Object arg9, Object arg10, Object arg11,
			Object arg12, Object arg13, Object arg14, Object arg15,
			Object arg16, Object arg17, Object arg18, Object arg19, Object arg20)
			throws RequestException, NoSuchMethodException {
		Object[] theArgs = { arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
				arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17,
				arg18, arg19, arg20 };
		return handlerRPCRequest(target, method, theArgs);
	}

	// ////////////////////////////////////////////////////////////////////
	// ////// End of Methods Exported to Request Client ///////////////////
	// ////////////////////////////////////////////////////////////////////

	// ////////////////////////////////////////////////////////////////
	// ////////////////////////////////////////////////////////////////
	// /////// Inner classes
	// ////////////////////////////////////////////////////////////////
	// ////////////////////////////////////////////////////////////////

	/**
	 * This inner class is used in conjunction with the <em>rpcRequest</em>
	 * method to determine if a matching reply has been received for a
	 * particular request.
	 */
	class RPCMatchingReply implements QueueSearch {
		/**
		 * The ID of the original message. The reply message corresponding to
		 * the original request will have the srcID field set equal to our local
		 * srcID field.
		 */
		long srcID;

		/**
		 * The constructor for this class is used to assign the ID of the
		 * message of which we are awaiting a reply.
		 */
		public RPCMatchingReply(long srcMsg) {
			srcID = srcMsg;
		}

		/**
		 * We match a message if it is an instance of <em>RequestMsg</em> and
		 * its srcID field is equal to ours.
		 */
		public boolean queueEvalPred(Object arg) {
			return ((arg instanceof RequestMsg) && (srcID == ((RequestMsg) arg).srcID));
		}
	}

}
