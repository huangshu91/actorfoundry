//  Copyright Notice.
// 
//  UDPLayer - a simple UDP Network layer
//  Copyright (C) 1998  Thomas Heide Clausen <voop@cs.auc.dk>
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Library General Public
//  License as published by the Free Software Foundation;
//  version 2 of the License.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Library General Public License for more details.
//
//  You should have received a copy of the GNU Library General Public
//  License along with this library; if not, write to the
//  Free Software Foundation, Inc., 59 Temple Place - Suite 330,
//  Boston, MA  02111-1307, USA./  
// *************************************************************************

// Originally fom package voop.network.simple.UDP;
// This is the adopted version.

package osl.nameservice.subnet.network.UDP;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

import osl.nameservice.subnet.network.CallbackClient;
import osl.nameservice.subnet.network.Packet;
import osl.nameservice.subnet.network.TransportLayer;
import osl.scheduler.Scheduler;
import osl.util.WaitQueue;

/**
 * @author Thomas Heide Clausen <voop@cs.auc.dk>
 * @version 1.0b
 */
public class UDPLayer implements TransportLayer {

	/**
	 * Set this variable true to generate debugging information.
	 */
	private boolean debug = false;

	/**
	 * This queue holds the DATAGRAMS to send. They are generated by the
	 * send(p). Each datagram is the serialized packet p.
	 */
	private WaitQueue<DatagramPacket> toSend = new WaitQueue<DatagramPacket>();

	/**
	 * This is the CallbackClient, who will receive the callbacks once we get
	 * data on the network.
	 */
	private CallbackClient client;

	/**
	 * This variable defines the system scheduler.
	 */

	// private Scheduler s;
	/**
	 * This variable defines the quality of service, required from this layer.
	 */
	// private int quality;
	/**
	 * This variable defines the datagram size, used by this network layer.
	 */
	private int dgrm_size;

	/**
	 * This is the socket, used for all communication.
	 */
	private DatagramSocket mySocket;

	/**
	 * This is the InetAddress of the local host. Used to filter out our
	 * datagrams, and as Java unfortunately not return the "real" hostname when
	 * trying to use getLocalAddress() on a DatagramSocket, we have to provide
	 * this manually.
	 */
	private InetAddress myInetAddress;

	/**
	 * The following are meant to define the quality of service, as provided by
	 * this layer. As of now they are not implemented.
	 */
	public static final int UNRELIABLE = 0;

	/**
	 * This is the default initialization giving simple, unreliable services.
	 * 
	 * @param The
	 *            callback client
	 * @param Scheduler
	 *            s - the system scheduler.
	 */
	public UDPLayer(CallbackClient c, int size, int port, Scheduler s,
			InetAddress iad) {
		this(c, UDPLayer.UNRELIABLE, size, port, s, iad);
	}

	/**
	 * This is the initializor, allowing requirements to the quality of service
	 * 
	 * Furthermore two threads are started. One, whos purpose is to empty the
	 * toSend queue, and one, who is responsible for listening to incomming net
	 * packets and spawning callback threads.
	 * 
	 * @param int quality
	 * @param Scheduler
	 *            s
	 */
	public UDPLayer(CallbackClient c, int quality, int size, int port,
			Scheduler s, InetAddress iad) {
		// Introduce ourself.
		if (debug) {
			System.out.println("UDPLayer version 1.0b started...");
		}

		// Set local variables
		this.client = c;
		// this.quality = quality;
		this.dgrm_size = size;
		// this.s = s;
		this.myInetAddress = iad;

		// Initiate the socket.
		try {
			mySocket = new DatagramSocket(port);
		} catch (SocketException e) {
			System.out
					.println("Error starting the UDP-layer - cannot open socket: "
							+ e);
			System.exit(0);
		}
		if (debug) {
			System.out.println("***UDPLayer: Initialized");
			System.out.println("\tIP: " + mySocket.getLocalAddress());
			System.out.println("\tPort: " + mySocket.getLocalPort());
			System.out.println("\tDgramSize: " + this.dgrm_size);
		}

		s.scheduleThread(new Thread(new Helper(this, Helper.RECEIVE),
				"helperReceive"));
		s
				.scheduleThread(new Thread(new Helper(this, Helper.SEND),
						"helperSend"));
	}

	/**
	 * This method is invoked by the helper, and runs an infinite loop, waiting
	 * for contents in the toSend queue, and subsequentially blasts them onto
	 * the network.
	 */
	public void sendThread() {
		DatagramPacket dgp = null;

		if (debug) {
			System.out.println("***UDPLayer: sendThread() started");
		}
		while (true) {
			try {
				synchronized (toSend) {
					if (toSend.empty()) {
						toSend.wait();
					}
				}
			} catch (InterruptedException e) {
				System.out.println("Error: sendThread interrupted");
			}
			dgp = (DatagramPacket) toSend.dequeue();

			if (debug) {
				System.out.println("***UDPLayer: Dequeued packet");
				System.out.println("\tTgt. Addr: " + dgp.getAddress());
				System.out.println("\tTgt. Port: " + dgp.getPort());
			}

			try {
				mySocket.send(dgp);
			} catch (IOException e) {
				System.out.println("Error sending datagram: " + e);
			}
			if (debug) {
				System.out.println("***UDPLayer: datagram send.");
			}
		}
	}

	/**
	 * This method is invoked by the helper. The purpose is to check the network
	 * for incomming data. Read the datagrams, reconstruct the data in the
	 * datagrams to voop.network.simple.Packet's and spawn a new thread to
	 * perform the callback.
	 */
	public void receiveThread() {
		if (debug) {
			System.out.println("***UDPLayer: receiveThread() started");
			System.out.println("***UDPLayer: my InetAddress is: "
					+ myInetAddress);
		}

		byte[] t = new byte[dgrm_size];
		Object o = null;
		ByteArrayInputStream bis = null;
		ObjectInputStream ois = null;

		DatagramPacket dgp = new DatagramPacket(t, dgrm_size);

		while (true) {
			try {
				mySocket.receive(dgp);
			} catch (IOException e) {
				System.out.println("Error receiving datagram: " + e);
			}

			if (debug) {
				System.out
						.println("***UDPLayer: valid datagram received from: "
								+ dgp.getAddress());
			}
			//
			// Check if the datagram is send from ourself
			//
			if (!dgp.getAddress().equals(myInetAddress)) {
				if (debug) {
					System.out
							.println("***UDPLayer: received datagram from other: "
									+ dgp.getAddress());
				}
				try {
					bis = new ByteArrayInputStream(t);
					ois = new ObjectInputStream(bis);
					o = ois.readObject();
				} catch (Exception e) {
					System.out.println("Error extracting network data: " + e);
				}
				if (o instanceof Packet) {
					if (debug) {
						System.out
								.println("***UDPLayer: valid packet received");
					}
					client.callback((Packet) o);
				}
			}
		}
	}

	public void callbackThread() {
	}

	/**
	 * This method takes as argument the packet to send, and generates a
	 * datagram, based on the packet. That datagram is enqueued to be send, and
	 * the method returns. The data, that do NOT fit into at datagram of the
	 * size defined, are just discarded. That is: any overflow is thrown away.
	 */
	public void send(Packet p) {
		byte[] m = new byte[dgrm_size];

		// First we serialize the packet.
		try {
			ByteArrayOutputStream bas = new ByteArrayOutputStream();
			ObjectOutputStream oos = new ObjectOutputStream(bas);
			oos.writeObject(p);
			oos.flush();
			oos.close();

			// Now the packet is serialized. We need to make
			// sure, that it fits in a datagram, AND we need
			// to make sure that the datagram is full.
			//
			// First we get the bytes making up the packet, and
			// then we obtain the size of it. As the size is
			// defined as a (short), the max. size of the data can
			// be (dgrm_size-8) bytes. If there is any space left
			// it is filled with a "padding".
			byte[] data = bas.toByteArray();
			short size = (short) bas.size();

			System.arraycopy(data, 0, m, 0, size);
		} catch (IOException e) {
			System.out.println("ERROR: Could not serialize packet" + e);
		}

		// Then we generate the datagram.
		DatagramPacket datagram = new DatagramPacket(m, dgrm_size, p.target()
				.getAddress(), p.target().getPort());

		if (debug) {
			System.out.println("***UDPLayer: Datagram generated");
		}

		// Finally we enqueue it.
		toSend.enqueue(datagram);
	}

	public void close() {
	}
}
