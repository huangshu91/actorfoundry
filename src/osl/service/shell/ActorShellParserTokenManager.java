/* Generated By: 1.3 $ ($Date&JavaCC: Do not edit this line. ActorShellParserTokenManager.java */
package osl.service.shell;

public class ActorShellParserTokenManager implements ActorShellParserConstants {
	private final int jjStopStringLiteralDfa_0(int pos, long active0) {
		switch (pos) {
		case 0:
			if ((active0 & 0x20000000000L) != 0L) {
				jjmatchedKind = 42;
				return 57;
			}
			if ((active0 & 0x10000000L) != 0L)
				return 1;
			if ((active0 & 0xeffffe0L) != 0L) {
				jjmatchedKind = 42;
				return 28;
			}
			return -1;
		case 1:
			if ((active0 & 0x20000000000L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 1;
				return 55;
			}
			if ((active0 & 0xeffffe0L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 1;
				return 28;
			}
			return -1;
		case 2:
			if ((active0 & 0xeffffe0L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 2;
				return 28;
			}
			if ((active0 & 0x20000000000L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 2;
				return 78;
			}
			return -1;
		case 3:
			if ((active0 & 0x200047fbf60L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 3;
				return 28;
			}
			if ((active0 & 0xa804080L) != 0L)
				return 28;
			return -1;
		case 4:
			if ((active0 & 0x200007fbd40L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 4;
				return 28;
			}
			if ((active0 & 0x4000220L) != 0L)
				return 28;
			return -1;
		case 5:
			if ((active0 & 0x200005f8440L) != 0L) {
				if (jjmatchedPos != 5) {
					jjmatchedKind = 42;
					jjmatchedPos = 5;
				}
				return 28;
			}
			if ((active0 & 0x203900L) != 0L)
				return 28;
			return -1;
		case 6:
			if ((active0 & 0x1f9c40L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 6;
				return 28;
			}
			if ((active0 & 0x20000400000L) != 0L)
				return 28;
			return -1;
		case 7:
			if ((active0 & 0x179c40L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 7;
				return 28;
			}
			if ((active0 & 0x80000L) != 0L)
				return 28;
			return -1;
		case 8:
			if ((active0 & 0x178c00L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 8;
				return 28;
			}
			if ((active0 & 0x1040L) != 0L)
				return 28;
			return -1;
		case 9:
			if ((active0 & 0x58000L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 9;
				return 28;
			}
			if ((active0 & 0x120c00L) != 0L)
				return 28;
			return -1;
		case 10:
			if ((active0 & 0x58000L) != 0L) {
				jjmatchedKind = 42;
				jjmatchedPos = 10;
				return 28;
			}
			return -1;
		default:
			return -1;
		}
	}

	private final int jjStartNfa_0(int pos, long active0) {
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
	}

	private final int jjStopAtPos(int pos, int kind) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		return pos + 1;
	}

	private final int jjStartNfaWithStates_0(int pos, int kind, int state) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			return pos + 1;
		}
		return jjMoveNfa_0(state, pos + 1);
	}

	private final int jjMoveStringLiteralDfa0_0() {
		switch (curChar) {
		case 10:
			return jjStopAtPos(0, 24);
		case 46:
			return jjStartNfaWithStates_0(0, 28, 1);
		case 58:
			return jjStopAtPos(0, 47);
		case 60:
			return jjStopAtPos(0, 45);
		case 62:
			return jjStopAtPos(0, 46);
		case 83:
			return jjMoveStringLiteralDfa1_0(0x20000000000L);
		case 99:
			return jjMoveStringLiteralDfa1_0(0x3820L);
		case 100:
			return jjMoveStringLiteralDfa1_0(0x200000L);
		case 102:
			return jjMoveStringLiteralDfa1_0(0x4000000L);
		case 105:
			return jjMoveStringLiteralDfa1_0(0x180L);
		case 109:
			return jjMoveStringLiteralDfa1_0(0x1f8400L);
		case 110:
			return jjMoveStringLiteralDfa1_0(0x8000000L);
		case 112:
			return jjMoveStringLiteralDfa1_0(0x200L);
		case 114:
			return jjMoveStringLiteralDfa1_0(0x40L);
		case 115:
			return jjMoveStringLiteralDfa1_0(0x404000L);
		case 116:
			return jjMoveStringLiteralDfa1_0(0x2800000L);
		default:
			return jjMoveNfa_0(6, 0);
		}
	}

	private final int jjMoveStringLiteralDfa1_0(long active0) {
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(0, active0);
			return 1;
		}
		switch (curChar) {
		case 86:
			return jjMoveStringLiteralDfa2_0(active0, 0x20000000000L);
		case 97:
			return jjMoveStringLiteralDfa2_0(active0, 0x4000400L);
		case 101:
			return jjMoveStringLiteralDfa2_0(active0, 0x604040L);
		case 108:
			return jjMoveStringLiteralDfa2_0(active0, 0x20L);
		case 110:
			return jjMoveStringLiteralDfa2_0(active0, 0x180L);
		case 114:
			return jjMoveStringLiteralDfa2_0(active0, 0x2003a00L);
		case 115:
			return jjMoveStringLiteralDfa2_0(active0, 0x1f8000L);
		case 117:
			return jjMoveStringLiteralDfa2_0(active0, 0x8000000L);
		case 121:
			return jjMoveStringLiteralDfa2_0(active0, 0x800000L);
		default:
			break;
		}
		return jjStartNfa_0(0, active0);
	}

	private final int jjMoveStringLiteralDfa2_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(0, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(1, active0);
			return 2;
		}
		switch (curChar) {
		case 95:
			return jjMoveStringLiteralDfa3_0(active0, 0x20000000000L);
		case 99:
			return jjMoveStringLiteralDfa3_0(active0, 0x40L);
		case 101:
			return jjMoveStringLiteralDfa3_0(active0, 0x3800L);
		case 103:
			return jjMoveStringLiteralDfa3_0(active0, 0x1f8000L);
		case 105:
			return jjMoveStringLiteralDfa3_0(active0, 0x200L);
		case 107:
			return jjMoveStringLiteralDfa3_0(active0, 0x400L);
		case 108:
			return jjMoveStringLiteralDfa3_0(active0, 0xc200000L);
		case 110:
			return jjMoveStringLiteralDfa3_0(active0, 0x4000L);
		case 111:
			return jjMoveStringLiteralDfa3_0(active0, 0x20L);
		case 112:
			return jjMoveStringLiteralDfa3_0(active0, 0x800000L);
		case 114:
			return jjMoveStringLiteralDfa3_0(active0, 0x400000L);
		case 115:
			return jjMoveStringLiteralDfa3_0(active0, 0x80L);
		case 117:
			return jjMoveStringLiteralDfa3_0(active0, 0x2000000L);
		case 118:
			return jjMoveStringLiteralDfa3_0(active0, 0x100L);
		default:
			break;
		}
		return jjStartNfa_0(1, active0);
	}

	private final int jjMoveStringLiteralDfa3_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(1, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(2, active0);
			return 3;
		}
		switch (curChar) {
		case 97:
			return jjMoveStringLiteralDfa4_0(active0, 0x3800L);
		case 100:
			if ((active0 & 0x4000L) != 0L)
				return jjStartNfaWithStates_0(3, 14, 28);
			break;
		case 101:
			if ((active0 & 0x800000L) != 0L)
				return jjStartNfaWithStates_0(3, 23, 28);
			else if ((active0 & 0x2000000L) != 0L)
				return jjStartNfaWithStates_0(3, 25, 28);
			return jjMoveStringLiteralDfa4_0(active0, 0x400L);
		case 103:
			return jjMoveStringLiteralDfa4_0(active0, 0x170000L);
		case 105:
			return jjMoveStringLiteralDfa4_0(active0, 0x80000L);
		case 108:
			if ((active0 & 0x8000000L) != 0L)
				return jjStartNfaWithStates_0(3, 27, 28);
			break;
		case 109:
			return jjMoveStringLiteralDfa4_0(active0, 0x200000L);
		case 110:
			return jjMoveStringLiteralDfa4_0(active0, 0x200L);
		case 111:
			return jjMoveStringLiteralDfa4_0(active0, 0x140L);
		case 113:
			return jjMoveStringLiteralDfa4_0(active0, 0x8000L);
		case 115:
			return jjMoveStringLiteralDfa4_0(active0, 0x20004000020L);
		case 116:
			if ((active0 & 0x80L) != 0L)
				return jjStartNfaWithStates_0(3, 7, 28);
			break;
		case 118:
			return jjMoveStringLiteralDfa4_0(active0, 0x400000L);
		default:
			break;
		}
		return jjStartNfa_0(2, active0);
	}

	private final int jjMoveStringLiteralDfa4_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(2, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(3, active0);
			return 4;
		}
		switch (curChar) {
		case 101:
			if ((active0 & 0x20L) != 0L)
				return jjStartNfaWithStates_0(4, 5, 28);
			else if ((active0 & 0x4000000L) != 0L)
				return jjStartNfaWithStates_0(4, 26, 28);
			return jjMoveStringLiteralDfa5_0(active0, 0x20000170000L);
		case 103:
			return jjMoveStringLiteralDfa5_0(active0, 0x400L);
		case 105:
			return jjMoveStringLiteralDfa5_0(active0, 0x400000L);
		case 107:
			return jjMoveStringLiteralDfa5_0(active0, 0x100L);
		case 110:
			return jjMoveStringLiteralDfa5_0(active0, 0x40L);
		case 115:
			return jjMoveStringLiteralDfa5_0(active0, 0x280000L);
		case 116:
			if ((active0 & 0x200L) != 0L)
				return jjStartNfaWithStates_0(4, 9, 28);
			return jjMoveStringLiteralDfa5_0(active0, 0x3800L);
		case 117:
			return jjMoveStringLiteralDfa5_0(active0, 0x8000L);
		default:
			break;
		}
		return jjStartNfa_0(3, active0);
	}

	private final int jjMoveStringLiteralDfa5_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(3, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(4, active0);
			return 5;
		}
		switch (curChar) {
		case 99:
			return jjMoveStringLiteralDfa6_0(active0, 0x400000L);
		case 101:
			if ((active0 & 0x100L) != 0L)
				return jjStartNfaWithStates_0(5, 8, 28);
			else if ((active0 & 0x2000L) != 0L) {
				jjmatchedKind = 13;
				jjmatchedPos = 5;
			}
			return jjMoveStringLiteralDfa6_0(active0, 0x9800L);
		case 103:
			if ((active0 & 0x200000L) != 0L)
				return jjStartNfaWithStates_0(5, 21, 28);
			break;
		case 108:
			return jjMoveStringLiteralDfa6_0(active0, 0x20000000400L);
		case 110:
			return jjMoveStringLiteralDfa6_0(active0, 0x40L);
		case 114:
			return jjMoveStringLiteralDfa6_0(active0, 0x80000L);
		case 116:
			return jjMoveStringLiteralDfa6_0(active0, 0x170000L);
		default:
			break;
		}
		return jjStartNfa_0(4, active0);
	}

	private final int jjMoveStringLiteralDfa6_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(4, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(5, active0);
			return 6;
		}
		switch (curChar) {
		case 97:
			return jjMoveStringLiteralDfa7_0(active0, 0x20000L);
		case 101:
			if ((active0 & 0x400000L) != 0L)
				return jjStartNfaWithStates_0(6, 22, 28);
			return jjMoveStringLiteralDfa7_0(active0, 0x40L);
		case 102:
			if ((active0 & 0x20000000000L) != 0L)
				return jjStartNfaWithStates_0(6, 41, 28);
			break;
		case 105:
			return jjMoveStringLiteralDfa7_0(active0, 0x800L);
		case 108:
			return jjMoveStringLiteralDfa7_0(active0, 0x1000L);
		case 109:
			return jjMoveStringLiteralDfa7_0(active0, 0x10000L);
		case 111:
			return jjMoveStringLiteralDfa7_0(active0, 0x400L);
		case 112:
			return jjMoveStringLiteralDfa7_0(active0, 0x80000L);
		case 115:
			return jjMoveStringLiteralDfa7_0(active0, 0x40000L);
		case 116:
			return jjMoveStringLiteralDfa7_0(active0, 0x100000L);
		case 117:
			return jjMoveStringLiteralDfa7_0(active0, 0x8000L);
		default:
			break;
		}
		return jjStartNfa_0(5, active0);
	}

	private final int jjMoveStringLiteralDfa7_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(5, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(6, active0);
			return 7;
		}
		switch (curChar) {
		case 97:
			return jjMoveStringLiteralDfa8_0(active0, 0x100000L);
		case 98:
			return jjMoveStringLiteralDfa8_0(active0, 0x400L);
		case 99:
			if ((active0 & 0x80000L) != 0L)
				return jjStartNfaWithStates_0(7, 19, 28);
			return jjMoveStringLiteralDfa8_0(active0, 0x40L);
		case 101:
			return jjMoveStringLiteralDfa8_0(active0, 0x58000L);
		case 109:
			return jjMoveStringLiteralDfa8_0(active0, 0x800L);
		case 111:
			return jjMoveStringLiteralDfa8_0(active0, 0x1000L);
		case 114:
			return jjMoveStringLiteralDfa8_0(active0, 0x20000L);
		default:
			break;
		}
		return jjStartNfa_0(6, active0);
	}

	private final int jjMoveStringLiteralDfa8_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(6, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(7, active0);
			return 8;
		}
		switch (curChar) {
		case 97:
			return jjMoveStringLiteralDfa9_0(active0, 0x400L);
		case 99:
			if ((active0 & 0x1000L) != 0L)
				return jjStartNfaWithStates_0(8, 12, 28);
			break;
		case 103:
			return jjMoveStringLiteralDfa9_0(active0, 0x120000L);
		case 110:
			return jjMoveStringLiteralDfa9_0(active0, 0x40000L);
		case 112:
			return jjMoveStringLiteralDfa9_0(active0, 0x800L);
		case 115:
			return jjMoveStringLiteralDfa9_0(active0, 0x8000L);
		case 116:
			if ((active0 & 0x40L) != 0L)
				return jjStartNfaWithStates_0(8, 6, 28);
			return jjMoveStringLiteralDfa9_0(active0, 0x10000L);
		default:
			break;
		}
		return jjStartNfa_0(7, active0);
	}

	private final int jjMoveStringLiteralDfa9_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(7, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(8, active0);
			return 9;
		}
		switch (curChar) {
		case 100:
			return jjMoveStringLiteralDfa10_0(active0, 0x40000L);
		case 104:
			return jjMoveStringLiteralDfa10_0(active0, 0x10000L);
		case 105:
			return jjMoveStringLiteralDfa10_0(active0, 0x8000L);
		case 108:
			if ((active0 & 0x400L) != 0L)
				return jjStartNfaWithStates_0(9, 10, 28);
			else if ((active0 & 0x800L) != 0L)
				return jjStartNfaWithStates_0(9, 11, 28);
			break;
		case 115:
			if ((active0 & 0x20000L) != 0L)
				return jjStartNfaWithStates_0(9, 17, 28);
			else if ((active0 & 0x100000L) != 0L)
				return jjStartNfaWithStates_0(9, 20, 28);
			break;
		default:
			break;
		}
		return jjStartNfa_0(8, active0);
	}

	private final int jjMoveStringLiteralDfa10_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(8, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(9, active0);
			return 10;
		}
		switch (curChar) {
		case 101:
			return jjMoveStringLiteralDfa11_0(active0, 0x40000L);
		case 111:
			return jjMoveStringLiteralDfa11_0(active0, 0x10000L);
		case 122:
			return jjMoveStringLiteralDfa11_0(active0, 0x8000L);
		default:
			break;
		}
		return jjStartNfa_0(9, active0);
	}

	private final int jjMoveStringLiteralDfa11_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(9, old0);
		try {
			curChar = input_stream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(10, active0);
			return 11;
		}
		switch (curChar) {
		case 100:
			if ((active0 & 0x10000L) != 0L)
				return jjStartNfaWithStates_0(11, 16, 28);
			break;
		case 101:
			if ((active0 & 0x8000L) != 0L)
				return jjStartNfaWithStates_0(11, 15, 28);
			break;
		case 114:
			if ((active0 & 0x40000L) != 0L)
				return jjStartNfaWithStates_0(11, 18, 28);
			break;
		default:
			break;
		}
		return jjStartNfa_0(10, active0);
	}

	private final void jjCheckNAdd(int state) {
		if (jjrounds[state] != jjround) {
			jjstateSet[jjnewStateCnt++] = state;
			jjrounds[state] = jjround;
		}
	}

	private final void jjAddStates(int start, int end) {
		do {
			jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		} while (start++ != end);
	}

	private final void jjCheckNAddTwoStates(int state1, int state2) {
		jjCheckNAdd(state1);
		jjCheckNAdd(state2);
	}

	private final void jjCheckNAddStates(int start, int end) {
		do {
			jjCheckNAdd(jjnextStates[start]);
		} while (start++ != end);
	}

	/*
	 * private final void jjCheckNAddStates(int start) {
	 * jjCheckNAdd(jjnextStates[start]); jjCheckNAdd(jjnextStates[start + 1]); }
	 */static final long[] jjbitVec0 = { 0xfffffffffffffffeL,
			0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL };
	static final long[] jjbitVec2 = { 0x0L, 0x0L, 0xffffffffffffffffL,
			0xffffffffffffffffL };
	static final long[] jjbitVec3 = { 0x1ff00000fffffffeL, 0xffffffffffffc000L,
			0xffffffffL, 0x600000000000000L };
	static final long[] jjbitVec4 = { 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL };
	static final long[] jjbitVec5 = { 0x0L, 0xffffffffffffffffL,
			0xffffffffffffffffL, 0xffffffffffffffffL };
	static final long[] jjbitVec6 = { 0xffffffffffffffffL, 0xffffffffffffffffL,
			0xffffL, 0x0L };
	static final long[] jjbitVec7 = { 0xffffffffffffffffL, 0xffffffffffffffffL,
			0x0L, 0x0L };
	static final long[] jjbitVec8 = { 0x3fffffffffffL, 0x0L, 0x0L, 0x0L };

	private final int jjMoveNfa_0(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 78;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff)
				ReInitRounds();
			if (curChar < 64) {
				long l = 1L << curChar;
				// MatchLoop:
				do {
					switch (jjstateSet[--i]) {
					case 78:
						if ((0x3ff001000000000L & l) != 0L) {
							if (kind > 42)
								kind = 42;
							jjCheckNAdd(28);
						}
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(63, 64);
						if ((0x3ff000000000000L & l) != 0L) {
							if (kind > 37)
								kind = 37;
							jjCheckNAdd(56);
						}
						break;
					case 6:
						if ((0x3ff000000000000L & l) != 0L) {
							if (kind > 29)
								kind = 29;
							jjCheckNAddStates(0, 9);
						} else if (curChar == 45)
							jjCheckNAddStates(10, 16);
						else if (curChar == 36) {
							if (kind > 42)
								kind = 42;
							jjCheckNAdd(28);
						} else if (curChar == 34)
							jjCheckNAddStates(17, 19);
						else if (curChar == 39)
							jjAddStates(20, 21);
						else if (curChar == 46)
							jjCheckNAdd(1);
						if (curChar == 48) {
							if (kind > 29)
								kind = 29;
							jjCheckNAddStates(22, 26);
						}
						break;
					case 57:
					case 28:
						if ((0x3ff001000000000L & l) == 0L)
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 55:
						if ((0x3ff001000000000L & l) == 0L)
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 0:
						if (curChar == 46)
							jjCheckNAdd(1);
						break;
					case 1:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 33)
							kind = 33;
						jjCheckNAddStates(27, 29);
						break;
					case 3:
						if ((0x280000000000L & l) != 0L)
							jjCheckNAdd(4);
						break;
					case 4:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 33)
							kind = 33;
						jjCheckNAddTwoStates(4, 5);
						break;
					case 7:
						if ((0x280000000000L & l) != 0L)
							jjCheckNAdd(8);
						break;
					case 8:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 34)
							kind = 34;
						jjCheckNAdd(8);
						break;
					case 9:
						if (curChar == 39)
							jjAddStates(20, 21);
						break;
					case 10:
						if ((0xffffff7fffffdbffL & l) != 0L)
							jjCheckNAdd(11);
						break;
					case 11:
						if (curChar == 39 && kind > 35)
							kind = 35;
						break;
					case 13:
						if ((0x8400000000L & l) != 0L)
							jjCheckNAdd(11);
						break;
					case 14:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(15, 11);
						break;
					case 15:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAdd(11);
						break;
					case 16:
						if ((0xf000000000000L & l) != 0L)
							jjstateSet[jjnewStateCnt++] = 17;
						break;
					case 17:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAdd(15);
						break;
					case 18:
						if (curChar == 34)
							jjCheckNAddStates(17, 19);
						break;
					case 19:
						if ((0xfffffffbffffdbffL & l) != 0L)
							jjCheckNAddStates(17, 19);
						break;
					case 21:
						if ((0x8400000000L & l) != 0L)
							jjCheckNAddStates(17, 19);
						break;
					case 22:
						if (curChar == 34 && kind > 36)
							kind = 36;
						break;
					case 23:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAddStates(30, 33);
						break;
					case 24:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAddStates(17, 19);
						break;
					case 25:
						if ((0xf000000000000L & l) != 0L)
							jjstateSet[jjnewStateCnt++] = 26;
						break;
					case 26:
						if ((0xff000000000000L & l) != 0L)
							jjCheckNAdd(24);
						break;
					case 27:
						if (curChar != 36)
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 29:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 29)
							kind = 29;
						jjCheckNAddStates(0, 9);
						break;
					case 30:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 29)
							kind = 29;
						jjCheckNAddTwoStates(30, 31);
						break;
					case 32:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 30)
							kind = 30;
						jjCheckNAdd(32);
						break;
					case 33:
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(33, 34);
						break;
					case 34:
						if (curChar != 46)
							break;
						if (kind > 33)
							kind = 33;
						jjCheckNAddStates(34, 36);
						break;
					case 35:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 33)
							kind = 33;
						jjCheckNAddStates(34, 36);
						break;
					case 37:
						if ((0x280000000000L & l) != 0L)
							jjCheckNAdd(38);
						break;
					case 38:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 33)
							kind = 33;
						jjCheckNAddTwoStates(38, 5);
						break;
					case 39:
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(39, 40);
						break;
					case 41:
						if ((0x280000000000L & l) != 0L)
							jjCheckNAdd(42);
						break;
					case 42:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 33)
							kind = 33;
						jjCheckNAddTwoStates(42, 5);
						break;
					case 43:
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddStates(37, 39);
						break;
					case 45:
						if ((0x280000000000L & l) != 0L)
							jjCheckNAdd(46);
						break;
					case 46:
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(46, 5);
						break;
					case 47:
						if (curChar != 48)
							break;
						if (kind > 29)
							kind = 29;
						jjCheckNAddStates(22, 26);
						break;
					case 49:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 29)
							kind = 29;
						jjCheckNAddTwoStates(49, 31);
						break;
					case 50:
						if ((0xff000000000000L & l) == 0L)
							break;
						if (kind > 29)
							kind = 29;
						jjCheckNAddTwoStates(50, 31);
						break;
					case 52:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 31)
							kind = 31;
						jjstateSet[jjnewStateCnt++] = 52;
						break;
					case 53:
						if ((0xff000000000000L & l) == 0L)
							break;
						if (kind > 32)
							kind = 32;
						jjCheckNAdd(53);
						break;
					case 56:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 37)
							kind = 37;
						jjCheckNAdd(56);
						break;
					case 59:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						if (kind > 38)
							kind = 38;
						jjstateSet[jjnewStateCnt++] = 59;
						break;
					case 63:
						if ((0x3ff000000000000L & l) != 0L)
							jjCheckNAddTwoStates(63, 64);
						break;
					case 65:
						if ((0x3ff000000000000L & l) != 0L)
							jjAddStates(40, 41);
						break;
					case 69:
						if ((0x3ff000000000000L & l) != 0L)
							jjAddStates(42, 43);
						break;
					case 71:
						if ((0x3ff000000000000L & l) != 0L)
							jjAddStates(44, 45);
						break;
					case 75:
						if (curChar == 45)
							jjCheckNAddStates(10, 16);
						break;
					case 76:
						if (curChar == 48)
							jjCheckNAdd(48);
						break;
					case 77:
						if (curChar != 48)
							break;
						if (kind > 29)
							kind = 29;
						jjCheckNAddTwoStates(50, 31);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				long l = 1L << (curChar & 077);
				// MatchLoop:
				do {
					switch (jjstateSet[--i]) {
					case 78:
					case 28:
						if ((0x7fffffe87fffffeL & l) == 0L)
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 6:
						if ((0x7fffffe87fffffeL & l) != 0L) {
							if (kind > 42)
								kind = 42;
							jjCheckNAdd(28);
						}
						if ((0x2000000020L & l) != 0L)
							jjAddStates(46, 47);
						else if (curChar == 83)
							jjAddStates(48, 51);
						break;
					case 57:
						if ((0x7fffffe87fffffeL & l) != 0L) {
							if (kind > 42)
								kind = 42;
							jjCheckNAdd(28);
						}
						if (curChar == 86)
							jjstateSet[jjnewStateCnt++] = 73;
						if (curChar == 86)
							jjstateSet[jjnewStateCnt++] = 62;
						if (curChar == 86)
							jjstateSet[jjnewStateCnt++] = 60;
						if (curChar == 86)
							jjstateSet[jjnewStateCnt++] = 55;
						break;
					case 55:
						if ((0x7fffffe87fffffeL & l) != 0L) {
							if (kind > 42)
								kind = 42;
							jjCheckNAdd(28);
						}
						if (curChar == 71)
							jjstateSet[jjnewStateCnt++] = 68;
						else if (curChar == 95)
							jjstateSet[jjnewStateCnt++] = 63;
						if (curChar == 71)
							jjstateSet[jjnewStateCnt++] = 58;
						else if (curChar == 95)
							jjstateSet[jjnewStateCnt++] = 56;
						break;
					case 2:
						if ((0x2000000020L & l) != 0L)
							jjAddStates(52, 53);
						break;
					case 5:
						if ((0x5000000050L & l) != 0L && kind > 33)
							kind = 33;
						break;
					case 10:
						if ((0xffffffffefffffffL & l) != 0L)
							jjCheckNAdd(11);
						break;
					case 12:
						if (curChar == 92)
							jjAddStates(54, 56);
						break;
					case 13:
						if ((0x14404410000000L & l) != 0L)
							jjCheckNAdd(11);
						break;
					case 19:
						if ((0xffffffffefffffffL & l) != 0L)
							jjCheckNAddStates(17, 19);
						break;
					case 20:
						if (curChar == 92)
							jjAddStates(57, 59);
						break;
					case 21:
						if ((0x14404410000000L & l) != 0L)
							jjCheckNAddStates(17, 19);
						break;
					case 27:
						if ((0x7fffffe87fffffeL & l) == 0L)
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 31:
						if ((0x100000001000L & l) != 0L && kind > 29)
							kind = 29;
						break;
					case 36:
						if ((0x2000000020L & l) != 0L)
							jjAddStates(60, 61);
						break;
					case 40:
						if ((0x2000000020L & l) != 0L)
							jjAddStates(62, 63);
						break;
					case 44:
						if ((0x2000000020L & l) != 0L)
							jjAddStates(64, 65);
						break;
					case 48:
						if ((0x100000001000000L & l) != 0L)
							jjCheckNAdd(49);
						break;
					case 49:
						if ((0x7e0000007eL & l) == 0L)
							break;
						if (kind > 29)
							kind = 29;
						jjCheckNAddTwoStates(49, 31);
						break;
					case 51:
						if ((0x100000001000000L & l) != 0L)
							jjCheckNAdd(52);
						break;
					case 52:
						if ((0x7e0000007eL & l) == 0L)
							break;
						if (kind > 31)
							kind = 31;
						jjCheckNAdd(52);
						break;
					case 54:
						if (curChar == 83)
							jjAddStates(48, 51);
						break;
					case 58:
						if (curChar == 95)
							jjstateSet[jjnewStateCnt++] = 59;
						break;
					case 60:
						if (curChar == 71)
							jjstateSet[jjnewStateCnt++] = 58;
						break;
					case 61:
						if (curChar == 86)
							jjstateSet[jjnewStateCnt++] = 60;
						break;
					case 62:
						if (curChar == 95)
							jjstateSet[jjnewStateCnt++] = 63;
						break;
					case 64:
						if (curChar == 91)
							jjstateSet[jjnewStateCnt++] = 65;
						break;
					case 66:
						if (curChar == 93 && kind > 39)
							kind = 39;
						break;
					case 67:
						if (curChar == 86)
							jjstateSet[jjnewStateCnt++] = 62;
						break;
					case 68:
						if (curChar == 95)
							jjstateSet[jjnewStateCnt++] = 69;
						break;
					case 70:
						if (curChar == 91)
							jjstateSet[jjnewStateCnt++] = 71;
						break;
					case 72:
						if (curChar == 93 && kind > 40)
							kind = 40;
						break;
					case 73:
						if (curChar == 71)
							jjstateSet[jjnewStateCnt++] = 68;
						break;
					case 74:
						if (curChar == 86)
							jjstateSet[jjnewStateCnt++] = 73;
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				int hiByte = (curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				// MatchLoop:
				do {
					switch (jjstateSet[--i]) {
					case 78:
					case 28:
						if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 6:
						if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 57:
						if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 55:
						if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 42)
							kind = 42;
						jjCheckNAdd(28);
						break;
					case 10:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjstateSet[jjnewStateCnt++] = 11;
						break;
					case 19:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjAddStates(17, 19);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 78 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = input_stream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	static final int[] jjnextStates = { 30, 31, 32, 33, 34, 39, 40, 43, 44, 5,
			30, 76, 77, 33, 0, 39, 43, 19, 20, 22, 10, 12, 48, 50, 31, 51, 53,
			1, 2, 5, 19, 20, 24, 22, 35, 36, 5, 43, 44, 5, 65, 66, 69, 70, 71,
			72, 7, 8, 57, 61, 67, 74, 3, 4, 13, 14, 16, 21, 23, 25, 37, 38, 41,
			42, 45, 46, };

	private static final boolean jjCanMove_0(int hiByte, int i1, int i2,
			long l1, long l2) {
		switch (hiByte) {
		case 0:
			return ((jjbitVec2[i2] & l2) != 0L);
		default:
			if ((jjbitVec0[i1] & l1) != 0L)
				return true;
			return false;
		}
	}

	private static final boolean jjCanMove_1(int hiByte, int i1, int i2,
			long l1, long l2) {
		switch (hiByte) {
		case 0:
			return ((jjbitVec4[i2] & l2) != 0L);
		case 48:
			return ((jjbitVec5[i2] & l2) != 0L);
		case 49:
			return ((jjbitVec6[i2] & l2) != 0L);
		case 51:
			return ((jjbitVec7[i2] & l2) != 0L);
		case 61:
			return ((jjbitVec8[i2] & l2) != 0L);
		default:
			if ((jjbitVec3[i1] & l1) != 0L)
				return true;
			return false;
		}
	}

	public static final String[] jjstrLiteralImages = { "", null, null, null,
			null, "\143\154\157\163\145",
			"\162\145\143\157\156\156\145\143\164", "\151\156\163\164",
			"\151\156\166\157\153\145", "\160\162\151\156\164",
			"\155\141\153\145\147\154\157\142\141\154",
			"\143\162\145\141\164\145\151\155\160\154",
			"\143\162\145\141\164\145\154\157\143", "\143\162\145\141\164\145",
			"\163\145\156\144",
			"\155\163\147\161\165\145\165\145\163\151\172\145",
			"\155\163\147\147\145\164\155\145\164\150\157\144",
			"\155\163\147\147\145\164\141\162\147\163",
			"\155\163\147\147\145\164\163\145\156\144\145\162",
			"\155\163\147\151\163\162\160\143",
			"\155\163\147\147\145\164\164\141\147\163",
			"\144\145\154\155\163\147", "\163\145\162\166\151\143\145",
			"\164\171\160\145", "\12", "\164\162\165\145",
			"\146\141\154\163\145", "\156\165\154\154", "\56", null, null,
			null, null, null, null, null, null, null, null, null, null,
			"\123\126\137\163\145\154\146", null, null, null, "\74", "\76",
			"\72", };
	public static final String[] lexStateNames = { "DEFAULT", };
	static final long[] jjtoToken = { 0xe7ffffffffe1L, };
	static final long[] jjtoSkip = { 0x1eL, };
	private ASCII_UCodeESC_CharStream input_stream;
	private final int[] jjrounds = new int[78];
	private final int[] jjstateSet = new int[156];
	protected char curChar;

	public ActorShellParserTokenManager(ASCII_UCodeESC_CharStream stream) {
		if (ASCII_UCodeESC_CharStream.staticFlag)
			throw new Error(
					"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
		input_stream = stream;
	}

	public ActorShellParserTokenManager(ASCII_UCodeESC_CharStream stream,
			int lexState) {
		this(stream);
		SwitchTo(lexState);
	}

	public void ReInit(ASCII_UCodeESC_CharStream stream) {
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;
		ReInitRounds();
	}

	private final void ReInitRounds() {
		int i;
		jjround = 0x80000001;
		for (i = 78; i-- > 0;)
			jjrounds[i] = 0x80000000;
	}

	public void ReInit(ASCII_UCodeESC_CharStream stream, int lexState) {
		ReInit(stream);
		SwitchTo(lexState);
	}

	public void SwitchTo(int lexState) {
		if (lexState >= 1 || lexState < 0)
			throw new TokenMgrError("Error: Ignoring invalid lexical state : "
					+ lexState + ". State unchanged.",
					TokenMgrError.INVALID_LEXICAL_STATE);
		else
			curLexState = lexState;
	}

	private final Token jjFillToken() {
		Token t = Token.newToken(jjmatchedKind);
		t.kind = jjmatchedKind;
		String im = jjstrLiteralImages[jjmatchedKind];
		t.image = (im == null) ? input_stream.GetImage() : im;
		t.beginLine = input_stream.getBeginLine();
		t.beginColumn = input_stream.getBeginColumn();
		t.endLine = input_stream.getEndLine();
		t.endColumn = input_stream.getEndColumn();
		return t;
	}

	int curLexState = 0;
	int defaultLexState = 0;
	int jjnewStateCnt;
	int jjround;
	int jjmatchedPos;
	int jjmatchedKind;

	public final Token getNextToken() {
		Token matchedToken;
		int curPos = 0;

		EOFLoop: for (;;) {
			try {
				curChar = input_stream.BeginToken();
			} catch (java.io.IOException e) {
				jjmatchedKind = 0;
				matchedToken = jjFillToken();
				return matchedToken;
			}

			try {
				while (curChar <= 32 && (0x100003200L & (1L << curChar)) != 0L)
					curChar = input_stream.BeginToken();
			} catch (java.io.IOException e1) {
				continue EOFLoop;
			}
			jjmatchedKind = 0x7fffffff;
			jjmatchedPos = 0;
			curPos = jjMoveStringLiteralDfa0_0();
			if (jjmatchedKind != 0x7fffffff) {
				if (jjmatchedPos + 1 < curPos)
					input_stream.backup(curPos - jjmatchedPos - 1);
				if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
					matchedToken = jjFillToken();
					return matchedToken;
				} else {
					continue EOFLoop;
				}
			}
			int error_line = input_stream.getEndLine();
			int error_column = input_stream.getEndColumn();
			String error_after = null;
			boolean EOFSeen = false;
			try {
				input_stream.readChar();
				input_stream.backup(1);
			} catch (java.io.IOException e1) {
				EOFSeen = true;
				error_after = curPos <= 1 ? "" : input_stream.GetImage();
				if (curChar == '\n' || curChar == '\r') {
					error_line++;
					error_column = 0;
				} else
					error_column++;
			}
			if (!EOFSeen) {
				input_stream.backup(1);
				error_after = curPos <= 1 ? "" : input_stream.GetImage();
			}
			throw new TokenMgrError(EOFSeen, curLexState, error_line,
					error_column, error_after, curChar,
					TokenMgrError.LEXICAL_ERROR);
		}
	}

}
